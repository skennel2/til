## 1. JWT(JSON Web Token)의 기본 구조와 흐름

### **JWT의 구조**

JWT는 점(`.`)으로 구분된 세 부분으로 구성된다.

* **Header**: 사용된 알고리즘(예: HS256)과 토큰의 타입 명시.
* **Payload**: 사용자 ID, 권한, 만료 시간 등 실질적인 데이터(Claim) 포함.
* **Signature**: 서버의 비밀 키로 헤더와 페이로드를 암호화한 값. 변조 여부를 확인하는 핵심 장치.

### **인증 흐름**

1. **로그인**: 클라이언트가 자격 증명(ID/PW)을 서버에 전달.
2. **발급**: 서버는 정보를 검증한 뒤 JWT를 생성하여 응답.
3. **저장**: 클라이언트는 토큰을 로컬 스토리지 또는 쿠키에 저장.
4. **전송**: 이후 모든 요청의 HTTP 헤더(`Authorization: Bearer <token>`)에 토큰을 포함하여 전송.
5. **검증**: 서버는 별도의 DB 조회 없이 자신의 비밀 키로 서명을 검증하고 요청을 처리.

---

## 2. Redis의 주요 유즈케이스

JWT는 무상태(Stateless)를 지향하지만, 보안과 제어를 위해 Redis를 보조 수단으로 활용한다.

* **Refresh Token 관리**: Access Token 만료 시 재발급을 위한 Refresh Token을 저장. Redis의 **TTL(Time To Live)** 기능을 사용하여 만료 시 자동 삭제.
* **로그아웃 블랙리스트**: 로그아웃된 Access Token이 만료되기 전까지 악용되는 것을 막기 위해 해당 토큰을 Redis에 등록하고 요청 시마다 대조.
* **권한 정보 캐싱**: 복잡한 유저 권한이나 프로필 정보를 Redis에 캐싱하여 DB 부하를 줄이고 인가 속도를 높임.

---

## 3. HMAC과 데이터 무결성 보호

### **HMAC의 역할**

비밀 키와 메시지를 결합하여 해시값을 생성하는 방식이다. **무결성(데이터가 변하지 않음)**과 **인증(발신자 확인)**을 보장한다.

* **JWT 서명**: JWT의 Signature 생성 시 HMAC 알고리즘(HS256 등)이 표준적으로 사용됨.
* **S2S(Server to Server) 보안**: 서버 간 통신 시 요청 데이터에 비밀 키로 서명을 생성하여 전달함으로써 중간 위변조 방지.
* **웹훅 검증**: 외부 결제 API 등에서 들어오는 요청이 신뢰할 수 있는 출처인지 확인하기 위해 사용.

### **요청 파라미터 변조 방지 방법**

1. **파라미터 서명**: 전송할 파라미터를 정렬 후 HMAC으로 서명하여 `sig` 값을 함께 전송.
2. **타임스탬프/Nonce**: 요청 시각을 서명에 포함하여 동일한 요청을 가로채 다시 보내는 '재전송 공격' 차단.
3. **Body Checksum**: JSON 본문 전체의 해시값을 헤더에 담아 전송하여 본문 내용의 변조 여부 확인.

---

## 4. JWT의 실질적 가치와 한계

### **가치**

* **인가(Authorization)**: 페이로드에 사용자 권한(Role)을 담아 DB 조회 없이 즉각적인 권한 제어 가능.
* **확장성**: 서버가 클라이언트의 상태를 저장하지 않으므로 서버 대수를 늘리는 스케일 아웃에 유리.
* **자체 포함(Self-Contained)**: 토큰 자체가 정보를 들고 있어 시스템 간 통신 비용 절감.

### **한계**

* **탈취 위험**: 토큰이 노출되면 만료 전까지 서버에서 강제로 무효화하기 어려움(Redis 블랙리스트로 보완 필요).
* **데이터 크기**: 페이로드에 많은 정보를 담을수록 네트워크 대역폭 소모 증가.
