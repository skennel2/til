# 오버로딩

```java
public class Main {
    public static void main(String[] args) {
        OverloadingContainer t = new OverloadingContainer();
        SimpleObject dto = new SimpleObject();

        // 1. SimpleObject 타입 전달 -> 구체적인 메서드 호출
        t.overloadingTest(dto); 
        // 출력: "SimpleObject 메서드 호출됨"

        // 2. 다른 객체(String) 전달 -> Object 메서드 호출
        t.overloadingTest("Hello"); 
        // 출력: "Object 메서드 호출됨"
        
        // 3. Object 타입으로 업캐스팅 후 전달 (주의!)
        Object obj = new SimpleObject();
        t.overloadingTest(obj);
        // 출력: "Object 메서드 호출됨" (중요)
    }
}

class SimpleObject {}

class SimpleObjectExtends extends SimpleObject {}

class OverloadingContainer {

    public void overloadingTest(Object a) {
        System.out.println("Object 메서드 호출됨");
    }

    public void overloadingTest(SimpleObject a) {
        System.out.println("SimpleObject 메서드 호출됨");
    }

    public void overloadingTest(SimpleObjectExtends a) {
        System.out.println("SimpleObjectExtends 메서드 호출됨");
    }
}
```

void overloadingTest(Object a)  
void overloadingTest(SimpleObject a)  
void overloadingTest(SimpleObjectExtends a)
위 오버로딩은 문법적으로 합법하다. 상속구조로 묶여있다고해도 메소드 호출시 가장 구체적인 타입을 가진 파라미터를 우선적으로 선택한다.  
오버로딩은 컴파일시점에 어떤 메소드를 호출할지가 결정된다. (정적 바인딩)  
  
Object obj = new SimpleObject(); 와 같이 변수의 타입이 Object라면, 실제 인스턴스가 SimpleObject이더라도 컴파일러는 변수 타입인 Object를 기준으로 판단하여 overloadingTest(Object a)를 호출하게된다.