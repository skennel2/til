DBMS의 쿼리 결과 처리 메커니즘과 구체화(Materialization)의 핵심 내용을 문어체로 정리하여 기술한다.

---

# 1. DBMS의 데이터 전송 메커니즘: 스트리밍(Streaming)

DBMS는 대량의 결과 세트를 클라이언트에게 반환할 때, 모든 로우를 메모리에 일시적으로라도 전부 적재하지 않는 것을 원칙으로 한다.

* **동작 원리:** 쿼리 실행 엔진은 조건에 부합하는 로우를 찾는 즉시 **네트워크 전송 버퍼(Network Buffer)**에 기록한다. 해당 버퍼가 임계치에 도달하면 즉시 클라이언트로 데이터를 전송하며, 전송이 완료된 버퍼는 비워진 후 다음 데이터를 수용한다.
* **자원 효율성:** 이러한 스트리밍 방식을 통해 수억 건의 데이터 조회 시에도 메모리 점유율을 일정하게 유지하며, **OOM(Out Of Memory)** 장애를 방지한다.
* **응답 특성:** 첫 번째 로우를 반환하기까지의 시간(Time to First Row)이 짧아져 전체적인 응답 성능이 향상된다.

---

# 2. 구체화(Materialization)의 정의와 발생 원인

**구체화(Materialization)**란 쿼리 실행 과정 중 중간 결과 집합을 메모리나 디스크의 임시 공간에 물리적으로 생성하여 저장하는 일련의 과정을 의미한다.

## 발생 원인: 차단 연산자(Blocking Operators)

일부 연산은 전체 데이터 세트를 확인하기 전까지는 최종 결과를 확정할 수 없는 특성을 지닌다. 이를 **차단 연산자**라 하며, 이때 구체화가 수반된다.

* **정렬(ORDER BY):** 인덱스가 존재하지 않는 경우, 전체 데이터를 수집하여 정렬 순서를 결정해야 한다.
* **그룹화 및 집계(GROUP BY / Aggregation):** 전체 로우를 스캔하여 그룹별 통계치를 산출해야 하므로 중간 결과의 보관이 필수적이다.
* **해시 조인(Hash Join):** 조인 수행을 위해 한쪽 테이블의 데이터를 기반으로 메모리 내 해시 테이블을 생성하는 과정에서 발생한다.

## 자원 활용 단계

구체화 과정에서 우선적으로 세션별 할당 메모리(Work Memory)를 사용하며, 해당 공간이 부족할 경우 **디스크(Temp DB)**를 활용한다. 디스크 쓰기가 발생하는 시점부터 I/O 부하로 인한 급격한 성능 저하가 초래된다.

---

# 3. 파이프라이닝과 구체화의 비교

| 구분 | 파이프라이닝 (Pipelining) | 구체화 (Materialization) |
| --- | --- | --- |
| **처리 방식** | 데이터 발생 즉시 순차적 전송 | 전체 데이터 수집 후 일괄 처리 |
| **응답 시간** | 첫 로우 전송 속도가 매우 빠름 | 전체 연산 완료 후 응답 시작 | 
| **자원 소모** | 최소한의 메모리를 일정하게 사용 | 데이터 크기에 비례하여 자원 소모 증가 |
| **관련 연산** | 단순 조회, 인덱스 스캔, NL 조인 | 정렬, 그룹화, 인덱스 없는 조인 |

---

# 4. 최적화 및 주의사항

효율적인 데이터 처리를 위해 개발자는 다음의 사항을 고려해야 한다.

1. **인덱스 최적화:** `ORDER BY` 연산 시 인덱스를 활용하면 이미 정렬된 데이터를 스트리밍할 수 있어 구체화 과정을 생략할 수 있다.
2. **실행 계획 분석:** 쿼리 실행 계획에서 `Using temporary` 또는 `Using filesort` 발생 여부를 확인하여 불필요한 구체화 과정을 식별해야 한다.
3. **클라이언트 측 메모리 관리:** DBMS가 스트리밍 방식으로 데이터를 전송하더라도, 애플리케이션 계층에서 이를 `List` 등의 컬렉션에 전량 담는 행위는 클라이언트 측 OOM을 유발할 수 있다. 대용량 데이터는 페이징 처리 또는 스트림 API를 통한 순차 처리가 권장된다.

---

본 내용과 관련하여 실제 적용 중인 **Spring Boot 환경에서의 대용량 데이터 처리 전략(Cursor, Fetch Size 조절 등)**에 대해 추가적인 정보가 필요하시면 요청해 주시기 바랍니다.