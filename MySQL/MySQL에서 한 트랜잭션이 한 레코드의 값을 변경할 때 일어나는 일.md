# MySQL에서 한 트랜잭션이 한 레코드의 값을 UPDATE할 때 일어나는 일

## 트랜잭션 시작

1. **트랜잭션 ID 할당**:
   - 트랜잭션이 시작되면 InnoDB는 해당 트랜잭션에 고유한 트랜잭션 ID (Transaction ID)를 할당합니다.
   - 이 ID는 트랜잭션의 순서와 상태를 추적하는 데 사용됩니다.

## 레코드 변경 요청

2. **레코드 잠금 (Locking)**:
   - 트랜잭션이 특정 레코드를 변경하려고 할 때, InnoDB는 그 레코드에 대한 적절한 잠금을 설정합니다.
   - 일반적으로 InnoDB는 행 수준의 잠금을 사용합니다. 이 경우 변경되는 레코드는 X (exclusive) 락으로 잠깁니다.
   - 이 잠금은 다른 트랜잭션이 동일한 레코드에 대한 변경 작업을 시도하는 것을 방지합니다.

## 변경 사항 처리

3. **변경 전 데이터 저장 (Undo Log)**:
   - 변경 작업을 수행하기 전에 InnoDB는 현재 레코드의 상태를 언두 로그에 저장합니다.
   - 언두 로그는 트랜잭션이 롤백될 경우 변경된 데이터를 원래 상태로 복구할 수 있도록 합니다.
   - 또한 MVCC (Multi-Version Concurrency Control)를 지원하기 위해 이전 데이터 버전을 유지하는 데 사용됩니다.

4. **레코드 변경 (Update)**:
   - 트랜잭션은 이제 레코드의 값을 변경합니다. 이 변경 사항은 버퍼 풀에 있는 페이지에 기록됩니다.
   - 변경된 페이지는 버퍼 풀에 유지되며, 아직 디스크에 기록되지 않은 상태입니다.

5. **리두 로그 (Redo Log)**:
   - 변경 작업이 완료되면, InnoDB는 변경된 내용을 리두 로그에 기록합니다.
   - 리두 로그는 변경 작업을 재현할 수 있는 기록으로, 시스템 장애 시 데이터 복구에 사용됩니다.
   - 리두 로그는 일반적으로 메모리에 기록된 후 주기적으로 디스크에 플러시됩니다.

## 트랜잭션 커밋

6. **커밋 요청 (Commit)**:
   - 트랜잭션이 완료되고 커밋을 요청하면, InnoDB는 리두 로그를 디스크에 플러시합니다.
   - 이는 트랜잭션의 영속성을 보장합니다. 즉, 시스템 장애가 발생해도 커밋된 변경 사항은 손실되지 않습니다.

7. **잠금 해제 (Unlocking)**:
   - 트랜잭션이 커밋되면, 해당 레코드에 대한 잠금이 해제됩니다.
   - 다른 트랜잭션이 이제 이 레코드에 접근하고 변경할 수 있습니다.

## 트랜잭션 롤백

8. **롤백 요청 (Rollback)**:
   - 트랜잭션이 실패하거나 명시적으로 롤백을 요청하면, InnoDB는 언두 로그를 사용하여 변경된 레코드를 원래 상태로 복구합니다.
   - 이 과정에서 변경된 데이터는 언두 로그를 통해 되돌려지며, 해당 레코드는 롤백 이전 상태로 복원됩니다.

## 데이터 플러시

9. **데이터 플러시 (Flush)**:
   - 커밋된 변경 사항은 최종적으로 InnoDB의 백그라운드 프로세스에 의해 디스크에 플러시됩니다.
   - 이 과정에서 변경된 페이지는 디스크의 실제 데이터 파일에 기록됩니다.

## 요약

한 트랜잭션이 한 레코드의 값을 변경할 때 일어나는 일련의 과정은 데이터베이스의 일관성, 동시성, 영속성을 보장하기 위해 복잡하게 설계되어 있습니다. 이 과정은 트랜잭션 ID 할당, 레코드 잠금, 언두 로그 기록, 리두 로그 기록, 커밋, 잠금 해제, 롤백 시 언두 로그 사용, 그리고 최종적으로 데이터 플러시를 포함합니다. 이를 통해 InnoDB는 데이터 무결성을 유지하고 시스템 장애 시 데이터 복구를 보장할 수 있습니다.
